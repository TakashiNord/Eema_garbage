

  Фаза 1.
   отработка логики и интерфейсов


 0) Иерархия

select * from sys_db_part where define_alias like 'DA_SUBSYST'

DA_SUBSYST
ARC_READ
MODEL_SUBSYST

select id,id_parent, name, id_lsttbl 
from sys_tree21 
where id_parent in (
select distinct id_parent from sys_tree21 where id_lsttbl in 
(select id from sys_tbllst where id_type in
(select id from sys_otyp where define_alias like 'LST') 
and id_node in 
(select id from sys_db_part where id_parent in 
(select id from sys_db_part where define_alias like 'MODEL_SUBSYST' or define_alias like 'DA_SUBSYST' ))))

select id, NVL(id_parent,0), name, NVL(id_lsttbl,0) 
from sys_tree21 
start with ID in 
(select distinct id_parent from sys_tree21 where id_lsttbl in 
(select id from sys_tbllst where id_type in
(select id from sys_otyp where define_alias like 'LST') 
and id_node in 
(select id from sys_db_part where id_parent in 
(select id from sys_db_part where define_alias like 'MODEL_SUBSYST')))) connect by prior id=id_parent order by id

select id, NVL(id_parent,0), name, NVL(id_lsttbl,0) 
from sys_tree21 
start with ID in 
(select distinct id_parent from sys_tree21 where id_lsttbl in 
(select id from sys_tbllst where id_type in
(select id from sys_otyp where define_alias like 'LST') 
and id_node in 
(select id from sys_db_part where id_parent in 
(select id from sys_db_part where define_alias like 'DA_SUBSYST')))) connect by prior id=id_parent order by id


 Ограничения

#define ARCH_MIN_DEPTH 24 // Minimal depth. Hours. (Default is 1 day)
#define ARCH_MAX_DEPTH 100000 // Maximal depth. Hours. (Default is about 10 years)

#define ARCH_MIN_PART_DEPTH 10 // Minimal partition depth. Minutes. (Default is 10 minutes)
#define ARCH_MAX_PART_DEPTH 525600 // Maximal partition depth. Minutes. (Default is 1 year)

#define ARCH_MIN_PART_COUNT 1 // Minimal partitions count
#define ARCH_MAX_PART_COUNT 63 // Maximal partitions count
#define ARCH_DEFAULT_PARTITION_COUNT 12 // Default partitions count


 Работа с табл SYS_GTOPT

SELECT 
  SYS_GTOPT.ID      , 
  SYS_GTOPT.NAME    , 
  SYS_GTYP.DEFINE_ALIAS as "DataType",
  SYS_GTOPT.INTERVAL as "Interval (sec)"
  , SYS_ATYP.NAME as "Archive Type"
FROM SYS_GTOPT, SYS_GTYP, SYS_ATYP
WHERE SYS_GTYP.id=SYS_GTOPT.ID_GTYPE
AND SYS_GTOPT.ID_ATYPE=SYS_ATYP.ID


SELECT 
  SYS_GTOPT.ID
  ,SYS_GTOPT.NAME
  ,SYS_GTYP.DEFINE_ALIAS as "DataType"
  ,SYS_GTOPT.INTERVAL as "Interval (sec)"
  ,'0' as "Archive Type"
FROM SYS_GTOPT, SYS_GTYP
WHERE SYS_GTOPT.ID_ATYPE is null and SYS_GTYP.id=SYS_GTOPT.ID_GTYPE
union
SELECT 
  SYS_GTOPT.ID
  ,SYS_GTOPT.NAME
  ,SYS_GTYP.DEFINE_ALIAS as "DataType"
  ,SYS_GTOPT.INTERVAL as "Interval (sec)"
  ,SYS_ATYP.NAME as "Archive Type"
FROM SYS_GTOPT , SYS_ATYP, SYS_GTYP
WHERE SYS_GTOPT.ID_ATYPE=SYS_ATYP.ID  and SYS_GTYP.id=SYS_GTOPT.ID_GTYPE


- Биты масок 

 MASK

1	Запись по изменению	ARC_FTR_WRITE_ON_CHANGE	1
2	Запись экстремумов на интервале	ARC_FTR_WRITE_MINMAX	2
3	Использование партиций для доступа к архивам	ARC_FTR_USE_VIEW	4
4	Тип архива в архивной таблице	ARC_FTR_GTOPT_IN_ARCHIVE	8
5	Обновление данных в архиве	ARC_FTR_ARC_MERGE	16
6	Автоматическое восстановление архива	ARC_FTR_AUTORESTR	32
7	Использовать интерфейс прямой загрузки	ARC_FTR_DPLOAD_ON	64
8	Использование представлений на базовых архивах	ARC_FTR_USE_VIEW_ON_BASE	128
9	Усреднение на границе интервала	ARC_FTR_AVERAGE	256
10	В расчете участвуют величины с учетом исходного знака	ARC_FTR_CALC_SIGN	512
11	В расчете участвуют величины взятые по модулю	ARC_FTR_CALC_ABS	1024
12	В расчете участвуют только положительные величины	ARC_FTR_CALC_INPUT	2048
13	В расчете участвуют только отрицательные величины	ARC_FTR_CALC_OUTPUT	4096
14	Использовать метод трапеций для расчёта интеграла	ARC_FTR_CALC_TRAPEZOID	8192
15	Использование представлений на журналах	ARC_FTR_USE_VIEW_ON_JOUR	16384


 Табл ARC_GINFO

COMMENT ON COLUMN ARC_GINFO.ID IS 'Идентификатор профиля архива';
COMMENT ON COLUMN ARC_GINFO.ID_GTOPT IS 'Тип архива';
COMMENT ON COLUMN ARC_GINFO.ID_TYPE IS 'Ссылка на справочник ARC_TYPE';
COMMENT ON COLUMN ARC_GINFO.DEPTH IS 'Глубина архива в БД архивов, в часах. Значение 0 - архив неограниченной глубины';
COMMENT ON COLUMN ARC_GINFO.DEPTH_LOCAL IS 'Глубина архива в локальной БД, в часах. Значение 0 - архив с неограниченной глубиной';
COMMENT ON COLUMN ARC_GINFO.CACHE_SIZE IS 'Объем данных ("строк"), при котором сервер записи архивов отправляет данные на вставку серверу прямого доступа';
COMMENT ON COLUMN ARC_GINFO.CACHE_TIMEOUT IS 'Промежуток времени (сек), через который сервер записи архивов отправляет данные на вставку серверу прямого доступа';
COMMENT ON COLUMN ARC_GINFO.FLUSH_INTERVAL IS 'Период (сек) чистки устаревших данных. Значение 0 - не исполняется';
COMMENT ON COLUMN ARC_GINFO.RESTORE_INTERVAL IS 'Период (сек) контроля целостности архивных данных. Значение 0 - непрерывное исполнение';
COMMENT ON COLUMN ARC_GINFO.STACK_INTERVAL IS 'Период (сек) разбора таблицы - стека. Значение 0 - не исполняется';
COMMENT ON COLUMN ARC_GINFO.WRITE_MINMAX IS 'Записывать минимальное и максимальное значение на интервале (1 - записывать, 0 - не записывать)';
COMMENT ON COLUMN ARC_GINFO.RESTORE_TIME IS 'Период, по истечении которого прекращаются попытки восстановить архив из внешней подсистемы';
COMMENT ON COLUMN ARC_GINFO.NAME IS 'Наименование профиля архива';
COMMENT ON COLUMN ARC_GINFO.DEPTH_PARTITION IS 'Глубина хранения среза в разделе (в часах). По умолчанию - 3 часа';
COMMENT ON COLUMN ARC_GINFO.RESTORE_TIME_LOCAL IS 'Время, в течение которого возможно восстановление параметра из локального архива';

CREATE TABLE ARC_GINFO
(
  ID                  NUMBER(11),
  ID_GTOPT            NUMBER(11),
  ID_TYPE             NUMBER(11)                DEFAULT 1,
  DEPTH               NUMBER(11)                DEFAULT 168,
  DEPTH_LOCAL         NUMBER(11)                DEFAULT 168,
  CACHE_SIZE          NUMBER(11)                DEFAULT 200000,
  CACHE_TIMEOUT       NUMBER(11)                DEFAULT 5,
  FLUSH_INTERVAL      NUMBER(11)                DEFAULT 86400,
  RESTORE_INTERVAL    NUMBER(11)                DEFAULT 3600,
  STACK_INTERVAL      NUMBER(11)                DEFAULT 60,
  WRITE_MINMAX        NUMBER(11)                DEFAULT 0,
  RESTORE_TIME        NUMBER(11)                DEFAULT 168,
  NAME                VARCHAR2(255 BYTE),
  STATE               NUMBER(11)                DEFAULT 0,
  DEPTH_PARTITION     NUMBER(11)                DEFAULT 3,
  RESTORE_TIME_LOCAL  NUMBER(11)                DEFAULT 0
)


// delete

ARC_SUBSYST_PROFILE
  ID

ARC_SERVICES_TUNE
  ID_SPROFILE = ID

ARC_SERVICES_ACCESS
  ID_SPROFILE=ID
  
  
// create

-- определения id заданной таблицы-списка сбора

select id into nID_TBLLST from RSDUADMIN.SYS_TBLLST where table_name = '&TblLstName';

  pARC_PROFILE := 'MEAS_ARC_' || nID_TBLLST || '_' || nId_ARCGINFO;
>>> Вставка в ARC_SUBSYST_PROFILE нового профиля архивов: '|| pARC_PROFILE);
Insert into RSDUADMIN.ARC_SUBSYST_PROFILE (ID, ID_TBLLST, ID_GINFO, IS_WRITEON, STACK_NAME, LAST_UPDATE, IS_VIEWABLE)
 Values (nID_SPROFILE, nID_TBLLST, nID_ARCGINFO, 0, pARC_PROFILE, 0, 1);


select * from ad_service where define_alias like 'ADV_SRVC_DPLOADADCP_ACCESPORT%' order by id asc

>>> Вставка в ARC_SERVICES_TUNE настроек для записи нового профиля архивов:');

  select id from ad_service where define_alias like 'ADV_SRVC_DPLOADADCP_ACCESPORT%' order by id asc
  nID_PRIORITY := nID_PRIORITY + 1;

  Insert into RSDUADMIN.ARC_SERVICES_TUNE(ID_SPROFILE, ID_SERVICE, PRIORITY)
           Values (nID_SPROFILE, rec.id, nID_PRIORITY);
  end loop;

-- Триггер для автоматического формирования имени табл-стека для профиля

     SELECT upper(table_name) INTO vArcDescName
       FROM sys_tbllst lst, sys_tbllnk lnk, sys_otyp t
      WHERE lnk.id_lsttbl = :NEW.id_tbllst
        AND lnk.id_dsttbl = lst.ID
        AND lst.id_type = t.ID
        AND t.define_alias LIKE 'ARH';

   :NEW.Stack_Name := vArcDescName || '_' || :NEW.id_tbllst|| '_' || :NEW.id_ginfo;

UPPER(TABLE_NAME) ID_LSTTBL

CALC_ARC  1140
DG_ARC  1320
MEAS_ARC  2001
MEAS_ARC  2002
MEAS_ARC  2003
DA_ARC  2005
DA_ARC  2006
DA_ARC  2007
DA_ARC  2008
DA_ARC  2009
DA_ARC  1000443
DA_ARC  1000483
MEAS_ARC  1000522
MEAS_ARC  1000532
EA_ARC  64
MEAS_ARC  116
REG_ARC 843
EA_ARC  881
DA_ARC  893
DA_ARC  896
MEAS_ARC  29
MEAS_ARC  33
MEAS_ARC  35
DA_ARC  54
DA_ARC  57
DA_ARC  59


 --
 -- номер табл = табл=имя архивной табл=название схемы
 --
select DISTINCT y.ID id_tbllst, y.table_name lst_tblname, x.table_name arc_tblname, sch.SCHEMA_NAME
               from sys_tbllst x, sys_tbllst y, sys_tbllnk st, sys_otyp ot, arc_db_schema sch, arc_services_info si
              where y.ID = st.id_lsttbl
                and x.ID = st.id_dsttbl
                and x.id_type = ot.id
                and ot.define_alias = 'ARH'
                and si.ID_DB_SCHEMA = sch.ID--(+)
                and si.ID_LSTTBL(+) = y.ID
              order by y.id



select DISTINCT y.ID id_tbllst, y.table_name lst_tblname, x.table_name arc_tblname, sch.SCHEMA_NAME
               from sys_tbllst x, sys_tbllst y, sys_tbllnk st, sys_otyp ot, arc_db_schema sch, arc_services_info si
              where y.ID = st.id_lsttbl
                and x.ID = st.id_dsttbl
                and x.id_type = ot.id
                and ot.define_alias = 'ARH'
                and si.ID_DB_SCHEMA = sch.ID
                and si.ID_LSTTBL = y.ID
              order by y.id




#define SRV_ARCSUBSYSTEM_SQL "SELECT y.ID id_tbllst, y.table_name lst_tblname, x.table_name arc_tblname, sch.SCHEMA_NAME arc_schema_name \
  FROM sys_tbllnk st \
  inner join sys_tbllst x on x.ID = st.id_dsttbl \
  inner join sys_tbllst y on y.ID = st.id_lsttbl \
  left join arc_services_info si on si.ID_LSTTBL = y.ID \
  left join arc_db_schema sch on si.ID_DB_SCHEMA = sch.ID \
  inner join sys_otyp ot on x.id_type = ot.ID \
  WHERE ot.define_alias = 'ARH' \
  ORDER BY y.ID"


define SRV_ARCSUBSYSTEM_SQL 
SELECT y.ID id_tbllst, y.table_name lst_tblname, x.table_name arc_tblname, sch.SCHEMA_NAME arc_schema_name 
    FROM sys_tbllst x, sys_tbllst y, sys_tbllnk st, sys_otyp ot, arc_db_schema sch, arc_services_info si 
    WHERE y.ID = st.id_lsttbl 
        AND x.ID = st.id_dsttbl 
        AND x.id_type = ot.ID \
        AND ot.define_alias = 'ARH' 
        AND si.ID_DB_SCHEMA = sch.ID(+) 
        AND si.ID_LSTTBL(+) = y.ID 
    ORDER BY y.ID







SELECT 
   ad_pinfo.portnumber,ad_pinfo.id_proto,ad_sinfo.id_lsttbl,ad_list.id_type,
   sys_otyp.alias,ad_service.NAME,ad_service.define_alias 
      FROM ad_dir,
           ad_dir dir1,
           ad_list,
           ad_pinfo,
           ad_ncard,
           ad_sinfo,
           sys_otyp,
           ad_service,
           ad_hosts
     WHERE ad_sinfo.id_server_node = ad_dir.ID
       AND ad_list.id_node = ad_dir.ID
       AND ad_pinfo.id_param = ad_list.ID
       AND ad_pinfo.id_intrface_node = ad_ncard.id_node
       AND ad_list.id_type = sys_otyp.ID
       AND ad_pinfo.portnumber = ad_service.ID
       AND ad_pinfo.id_intrface_node = dir1.ID
       AND dir1.id_parent = ad_hosts.id_host_node
       AND ad_pinfo.id_proto > 2
       AND ad_pinfo.id_proto <> 9
       AND ad_dir.ID IN (SELECT ad_dir.ID FROM ad_dir WHERE ad_dir.id_type > 1000)
	   AND ad_sinfo.ID_LSTTBL=
    UNION
    SELECT 
      ad_pinfo.portnumber,ad_pinfo.id_proto,ad_sinfo.id_lsttbl,ad_list.id_type,
      sys_otyp.alias,ad_service.NAME,ad_service.define_alias 
      FROM ad_dir,
           ad_dir dir1,
           ad_list,
           ad_pinfo,
           ad_ipinfo,
           ad_sinfo,
           sys_otyp,
           ad_service,
           ad_hosts
     WHERE ad_sinfo.id_server_node = ad_dir.ID
       AND ad_list.id_node = ad_dir.ID
       AND ad_pinfo.id_param = ad_list.ID
       AND ad_pinfo.id_intrface_node = ad_ipinfo.id_node
       AND ad_list.id_type = sys_otyp.ID
       AND ad_pinfo.portnumber = ad_service.ID
       AND ad_pinfo.id_intrface_node = dir1.ID
       AND dir1.id_parent = ad_hosts.id_host_node
       AND ((ad_pinfo.id_proto <= 2) OR (ad_pinfo.id_proto = 9))
       AND ad_dir.ID IN (SELECT ad_dir.ID  FROM ad_dir WHERE ad_dir.id_type > 1000)
	   AND ad_sinfo.ID_LSTTBL=




 1\   SELECT upper(lst.TABLE_NAME) FROM sys_tbllst lst WHERE lst.ID  =  ======29

DA_V_LST_      ADV_SRVC_DCSOICTCP_ACCESSPORT  ADV_SRVC_DCSOIC_ACCESPORT
PHREG_LIST_V   ADV_SRVC_PHROIC_ACCESPORT%
ELREG_LIST_V   ADV_SRVC_ELROIC_ACCESPORT%

PSWT_LIST_V    ADV_SRVC_PWSOIC_ACCESPORT
AUTO_LIST_V    ADV_SRVC_SSWOIC_ACCESPORT      dpload --
EA_CHANNELS    --------- ADV_SRVC_RDAADCP_ACCESPORT
EA_V_CONSUMER_POINTS  -----------
CALC_LIST       --------
DG_LIST         ADV_SRVC_RDAADCP_ACCESPORT   dpload --
EXDATA_LIST_V   ADV_SRVC_RDAADCP_ACCESPORT   dpload --


if DA_V_LST_
  select * from ad_service where define_alias like 'ADV_SRVC_DCSOICTCP_ACCESSPORT%' order by id asc
ADV_SRVC_RDAADCP_ACCESPORT++++


-+ADV_SRVC_RDAOIC_ACCESPORT

-ADV_SRVC_RDAELOIC_ACCESPORT
-ADV_SRVC_RDAPHOIC_ACCESPORT
-ADV_SRVC_RDAPSOIC_ACCESPORT
-ADV_SRVC_RDADAOIC_ACCESPORT
-ADV_SRVC_RDAEAOIC_ACCESPORT

-- Вставка в ARC_SERVICES_ACCESS настроек для чтения нового профиля архивов:');
for rec in (
     select id from ad_service where define_alias like 'ADV_SRVC_PHROIC_ACCESPORT%' order by id asc
 )
        Insert into RSDUADMIN.ARC_SERVICES_ACCESS(ID_SPROFILE, ID_SERVICE, RETRO_DEPTH)
           Values (nID_SPROFILE, rec.id, 86400);
  end loop;





 -- Критическое нарушение целостности БДРВ  / Нарушение целостности БДРВ 

#define SRV_ITEGRITY_INFO_SQL  "select sbs.LAST_UPDATE, sbs.LAST_RELINK, sbs.REINIT_TYPE \
    from sys_db_part sbs, sys_tbllst lst \
    where lst.ID_NODE = sbs.ID AND lst.ID = %u"

 /* Достаточно выслать только ОДИН сигнал о нарушении БДРВ, то есть если есть критическое нарушение, то сообщаем только о нем */
            if (db_last_relink_time > (*SEnv).db_last_relink_time)
            {
                /* Критическое нарушение целостности БДРВ */
                sprintf((char *)qr,"WARNING! Real-time DB integrity CRITICAL error! You must rebuild and reload this job.");
                RSDURTGUtils_UnilogMessage(LOG_ERR, LogFile,"%s", qr);
                RSDURTGUtils_SS_SendTaskState(msg_port, (uint32_t)SS_INTEGRITY_A, SS_ALARM, LogFile, SEnv->FullPathName);
            }
            else
            {
                if (db_last_update_time > (*SEnv).db_last_update_time)
                {
                    /* Нарушение целостности БДРВ */
                    sprintf((char *)qr,"WARNING! Real-time DB integrity warning! You must reload this job.");
                    RSDURTGUtils_UnilogMessage(LOG_WARNING, LogFile,"%s", qr);
                    RSDURTGUtils_SS_SendTaskState(msg_port, (uint32_t)SS_INTEGRITY_W, SS_WARNING, LogFile, SEnv->FullPathName);
                }
            }





 -- 


COMMENT ON TABLE SYS_GTOPT IS 'Виды характеристик параметров поддерживаемых системой';
COMMENT ON COLUMN SYS_GTOPT.ID_GTYPE IS 'Глобальный тип данных параметра';
COMMENT ON COLUMN SYS_GTOPT.INTERVAL IS 'Интервал получения значений параметра';

FOR EACH ROW
DECLARE
 nErrNumber  NUMBER := 99999;
 sTEXT VARCHAR2(255) := ''Ошибка вставки в таблицу SYS_GTOPT - идентификатор принадлежит зарезервированному диапазону [1..1000].'';

CREATE TABLE SYS_GTOPT
(
  ID            NUMBER(11),
  NAME          VARCHAR2(255 BYTE),
  ALIAS         VARCHAR2(255 BYTE),
  ID_GTYPE      NUMBER(11),
  DEFINE_ALIAS  VARCHAR2(63 BYTE),
  INTERVAL      NUMBER(11),
  ID_ATYPE      NUMBER(11)
)


GRANT DELETE, INSERT, UPDATE ON SYS_GTYP TO BASE_STAND_ADJ;
GRANT SELECT ON SYS_GTYP TO BASE_STAND_READ;
COMMENT ON TABLE SYS_GTYP IS 'Глобальные типы данных';
COMMENT ON COLUMN SYS_GTYP.NAME IS 'Наименование глобального типа';
COMMENT ON COLUMN SYS_GTYP.DEFINE_ALIAS IS 'Уникальный символьный идентификатор типа';
CREATE TABLE SYS_GTYP
(
  ID            NUMBER(11),
  NAME          VARCHAR2(255 BYTE),
  DEFINE_ALIAS  VARCHAR2(63 BYTE),
  CIM_NAME      VARCHAR2(63 BYTE),
  DESCRIPTION   VARCHAR2(255 BYTE),
  ALIAS         VARCHAR2(255 CHAR),
  ID_ICON       NUMBER(11)                      DEFAULT NULL
)


  dbms_output.put_line ('Добавление данных в таблицу SYS_GTOPT:');
   --Отключим триггер, блокирующий вставку в зарезервированный для РСДУ диапазон ID
   for rec in (select trigger_name, status from all_triggers 
        where owner like 'RSDUADMIN' and trigger_name like 'SYS_GTOPT_ID_CHK_TR') loop
         execute  immediate 'alter trigger '||rec.trigger_name||' DISABLE';
   end loop;

--Включаем триггер обратно
for rec in (select trigger_name, status from all_triggers where owner like 'RSDUADMIN'  
	       and trigger_name like 'SYS_GTOPT_ID_CHK_TR') loop
    execute  immediate 'alter trigger '||rec.trigger_name||' ENABLE';
end loop;





SELECT SYS_GTOPT.* , SYS_GTYP.* , SYS_ATYP.*
FROM SYS_GTOPT , SYS_GTYP, SYS_ATYP
WHERE SYS_GTOPT.ID_GTYPE = SYS_GTYP.ID 
and SYS_GTOPT.ID_ATYPE = SYS_ATYP.ID


SELECT max(ID+1) FROM SYS_GTOPT WHERE ID+1 NOT IN (SELECT ID FROM SYS_GTOPT )

SELECT * FROM SYS_GTOPT 
WHERE ID_ATYPE in ( select id from SYS_ATYP where DEFINE_ALIAS like  'AGREGAT_TYPE_AVERAGE%' )
ORDER BY ID

SELECT * FROM SYS_GTOPT 
WHERE ID_ATYPE not in ( select id from SYS_ATYP ) or ID_ATYPE is null
ORDER BY ID

SELECT SYS_GTOPT.* , SYS_GTYP.NAME
FROM SYS_GTOPT , SYS_GTYP
WHERE SYS_GTOPT.ID_GTYPE = SYS_GTYP.ID




-- Незавершенные транзакции

SELECT COUNT(*)
       FROM v$transaction t, v$session s, v$mystat m
      WHERE t.ses_addr = s.saddr
        AND s.sid = m.sid
        AND ROWNUM = 1;


select s.sid
      ,s.serial#
      ,s.username
      ,s.machine
      ,s.status
      ,s.lockwait
      ,t.used_ublk
      ,t.used_urec
      ,t.start_time
from v$transaction t
inner join v$session s on t.addr = s.taddr;


select t.inst_id 
       ,s.sid
      ,s.serial#
      ,s.username
      ,s.machine
      ,s.status
      ,s.lockwait
      ,t.used_ublk
      ,t.used_urec
      ,t.start_time
from gv$transaction t
inner join gv$session s on t.addr = s.taddr;



COMMENT ON TABLE AD_SERV_INI_V IS 'Представление для просмотра инициализационных параметров модулей РВ';
CREATE OR REPLACE FORCE VIEW ad_serv_ini_v (login, parameter, VALUE)
AS
   (
SELECT
       u.ID       ID_USER,
       u.login login, r.NAME parameter, i.VALUE VALUE
      FROM ad_sinfo_ini i, ad_sinfo s, s_users u, rsdu_ini_param r
     WHERE s.id_server_node = i.id_server_node
       AND u.ID = s.id_user
       AND r.ID = i.id_ini_param);

=========================================================================

1++)

CREATE TABLE ARC_DB_SCHEMA (
    ID              DECIMAL        NOT NULL,
    NAME            NVARCHAR (255),
    SCHEMA_NAME     NVARCHAR (63),
    ID_STORAGE_TYPE DECIMAL
);

CREATE TABLE ARC_STORAGE_TYPE (
    ID           DECIMAL        NOT NULL,
    NAME         NVARCHAR (255),
    DEFINE_ALIAS NVARCHAR (63) 
);

select ads.ID, ads.NAME, ads.SCHEMA_NAME , ast.NAME as STORAGE
from ARC_DB_SCHEMA ads,  ARC_STORAGE_TYPE ast
where ads.ID_STORAGE_TYPE=ast.ID
order by ads.ID asc

CREATE TABLE ARC_SERVICES_INFO (
    ID_LSTTBL    DECIMAL NOT NULL,
    ID_SVC_TYPE  DECIMAL,
    ID_DB_SCHEMA DECIMAL NOT NULL
);

CREATE TABLE SYS_TBLLST (
    ID           DECIMAL        NOT NULL,
    ID_NODE      DECIMAL,
    NAME         NVARCHAR (255),
    TABLE_NAME   NVARCHAR (63),
    ID_TYPE      DECIMAL,
    DEFINE_ALIAS NVARCHAR (63),
    LAST_UPDATE  DECIMAL,
    ALIAS        NVARCHAR (255),
    ID_FILEWAV   DECIMAL
);

select asi.ID_LSTTBL, st.NAME, ads.ID_SVC_TYPE, asi.ID_DB_SCHEMA, ads.NAME as STORAGE
from ARC_DB_SCHEMA ads,  ARC_SERVICES_INFO asi, SYS_TBLLST st
where ads.ID=asi.ID_DB_SCHEMA and st.ID=asi.ID_LSTTBL


select asi.ID_LSTTBL, st.NAME
--, ads.ID_SVC_TYPE as TYPE
, asi.ID_DB_SCHEMA 
, ads.NAME as STORAGE
, ads.SCHEMA_NAME
from ARC_DB_SCHEMA ads, ARC_SERVICES_INFO asi, SYS_TBLLST st
where ads.ID=asi.ID_DB_SCHEMA and st.ID=asi.ID_LSTTBL
order by asi.ID_LSTTBL asc

